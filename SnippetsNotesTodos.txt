USAGE OF MAPS
    class AppConfig {
        
        //Might need  to compile with node flag -harmony to get Map functionality.
        environments: Map<string, EnvConfig>;
        
        constructor(envs : EnvConfig[]) {
            this.environments = new Map<string, EnvConfig>();
        }
    }
    
    
Set env in git bash:  export $NODE_ENV="development"
View env in git bash: echo $NODE_ENV

Useful Example Code OF Typescript + Express here:
https://github.com/Microsoft/vscode-samples/tree/master/node-express-typescript

Example of setting up a gulp / TypeScript workflow:
https://www.typescriptlang.org/docs/handbook/gulp.html

Decent explanation of module loading in ES6
http://www.2ality.com/2014/09/es6-modules-final.html

Typescript / project structure:
http://stackoverflow.com/questions/32501064/typescript-recommended-project-structure-with-modules


Refactors  
    Core/Markdown:
        default export Class MarkDown
            inject: fileHierarchy                            
            has a markdown property
            constructor should define all the renderers
            Process method(take txt as input)

    Core/MdFileProcessor
        inject: settings
        properties: 
            fdr: FileDataReader
            sdr: SiteDirectoryReader
            siteDirectory: string[] //might make this into it's own class
            fileHierarchy: string[] //might make this into it's own class
            breadcrumb: string[]
            title: []
            markdown: string
            
        method:
            ExtractTitle()
            ExtractBreadcrumb()
            ExtractFileHierarchy()
            ExtractSiteDirectory()
            InsertClosingHeader()
            
        
        Process() 
            returns the data needed by the view
            new up fdr and sdr and call fill() on both
            call local methods (or if I create classes)
                ExtractTitle()
                ExtractBreadcrumb()
                ExtractFileHierarchy()
                ExtractSiteDirectory()
                InsertClosingHeader()
            Rejoin the document array
            new up Markdown(fileHierarchy)
            md.Compile()
            Package data and return to router
                

    Core/ResourceResolver
        constructor: inject settings
    
        methods:
            RemoteResourceUrl
            LocalResourceUrl
            RemoteMdFileUrl
            LocalMdFileName
            RemoteIndexMdFileUrl
            LocalIndexMdFileUrl
        
        
    Core/FileDataReader
        Property: FileName
        Property: lines : string[]
         
        constructor:
            inject settings
            
        Fill()
            figure out if we're running remote(async) or local
            figure out which file is current and set FileName
            fills lines[]
                 
                 
    Core/SiteDirectoryReader
        rawFileList: string[]  //paths and filename
        splitFileList: string[][] //each segment in the path has a name
        
        constructor:       
            inject settings
            
        Fill()
            figure out if we're running async or local
            fill rawFileList[] and splitFileList[][]  
                
                
    
    router should 
        define routes
        call appropriate classes
        connect them to the callbacks
        should BE DUMB
    
     
Clean up all import statements
set strict typescript config
 
